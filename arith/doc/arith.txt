/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2010 Fredrik Johansson

******************************************************************************/

*******************************************************************************

    Factoring integers 

    An integer may be represented in factored form using the 
    \code{fmpz_factor_t} data structure. This consists of two \code{fmpz} 
    vectors representing bases and exponents, respectively. Canonically, 
    the bases will be prime numbers sorted in ascending order and the 
    exponents will be positive.

    A separate \code{int} field holds the sign, which may be $-1$, $0$ or $1$.

*******************************************************************************

void fmpz_factor_init(fmpz_factor_t factor)

    Initialises a \code{fmpz_factor_t} structure.

void fmpz_factor_clear(fmpz_factor_t factor)

    Clears a \code{fmpz_factor_t} structure.

void fmpz_factor(fmpz_factor_t factor, const fmpz_t n)

    Factors $n$ into prime numbers. If $n$ is zero or negative, the
    sign field of the \code{factor} object will be set accordingly.

    This currently only uses trial division, falling back to \code{n_factor()}
    as soon as the number shrinks to a single limb.

void fmpz_unfactor(fmpz_t n, const fmpz_factor_t factor)

    Evaluates an integer in factored form back to an \code{fmpz_t}.

    This currently exponentiates the bases separately and multiplies
    them together one by one, although much more efficient algorithms
    exist. 

*******************************************************************************

    Primorials

*******************************************************************************

void fmpz_primorial(fmpz_t res, long n)

    Sets \code{res} to ``$n$ primorial'' or $n \#$, the product of all prime 
    numbers less than or equal to $n$.

*******************************************************************************

    Harmonic numbers

*******************************************************************************

void mpq_harmonic(mpq_t res, long n)

    Sets $res$ to the $n$th harmonic number 
    $H_n = 1 + 1/2 + 1/3 + \dotsb + 1/n$.
    The result is zero if $n \leq 0$.

    Table lookup is used for $H_n$ whose numerator and denomator 
    fit in single limb. For larger $n$, the function 
    \code{mpn_harmonic_odd_balanced()} is used.

*******************************************************************************

    Stirling numbers

*******************************************************************************

void fmpz_stirling1u(fmpz_t s, long n, long k)

void fmpz_stirling1(fmpz_t s, long n, long k)

void fmpz_stirling2(fmpz_t s, long n, long k)

    Sets $s$ to $S(n,k)$ where $S(n,k)$ denotes an unsigned Stirling
    number of the first kind $\abs{S_1(n, k)}$, a signed Stirling number 
    of the first kind $S_1(n, k)$, or a Stirling number of the second 
    kind $S_2(n, k)$.  The Stirling numbers are defined using the 
    generating functions
    \begin{align*}
        x_{(n)} & = \sum_{k=0}^n S_1(n,k) x^k \\
        x^{(n)} & = \sum_{k=0}^n \abs{S_1(n,k)} x^k \\
        x^n     & = \sum_{k=0}^n S_2(n,k) x_{(k)}
    \end{align*}
    where $x_{(n)} = x(x-1)(x-2) \dotsm (x-n+1)$ is a falling factorial 
    and $x^{(n)} = x(x+1)(x+2) \dotsm (x+n-1)$ is a rising factorial.
    $S(n,k)$ is taken to be zero if $n < 0$ or $k < 0$.

    These three functions are useful for computing isolated Stirling 
    numbers efficiently. To compute a range of numbers, the vector or 
    matrix versions should generally be used.

void fmpz_stirling1u_vec(fmpz * row, long n, long klen)
void fmpz_stirling1_vec(fmpz * row, long n, long klen)
void fmpz_stirling2_vec(fmpz * row, long n, long klen)

    Computes the row of Stirling numbers
    \code{S(n,0), S(n,1), S(n,2), ..., S(n,klen-1)}.

    To compute a full row, this function can be called with 
    \code{klen = n+1}. It is assumed that \code{klen} is at most $n + 1$.

void fmpz_stirling1u_vec_next(fmpz * row, fmpz * prev, long n, long klen)
void fmpz_stirling1_vec_next(fmpz * row, fmpz * prev, long n, long klen)
void fmpz_stirling2_vec_next(fmpz * row, fmpz * prev, long n, long klen)

    Given the vector \code{prev} containing a row of Stirling numbers
    \code{S(n-1,0), S(n-1,1), S(n-1,2), ..., S(n-1,klen-2)}, computes
    and stores in the row argument 
    \code{S(n,0), S(n,1), S(n,2), ..., S(n,klen-1)}.
    It is assumed that \code{klen} is at most $n + 1$.

    The \code{row} and \code{prev} arguments are permitted to be the 
    same, meaning that the row will be update in-place.

void fmpz_stirling1u_mat(fmpz ** rows, long n)
void fmpz_stirling1_mat(fmpz ** rows, long n)
void fmpz_stirling2_mat(fmpz ** rows, long n)

    Computes an $n$-by-$n$ matrix of Stirling numbers:
    \begin{lstlisting}
    row 0   : S(0,0)
    row 1   : S(1,0), S(1,1)
    row 2   : S(2,0), S(2,1), S(2,2)
    row 3   : S(3,0), S(3,1), S(3,2), S(3,3)
                  ...
    row n-1 : S(n-1,0), S(n-1,1), ..., S(n-1,n-1)
    \end{lstlisting}

    In effect, if \code{rows} are the rows of an \code{fmpz_mat_t}, 
    this stores the Stirling number analogue of Pascal's triangle 
    as a lower triangular matrix, with ones on the main diagonal; 
    entries above the main diagonal will not be touched, and should 
    be zeroed by the caller if necessary.

    For any $n$, the $S_1$ and $S_2$ matrices thus obtained are 
    inverses of each other.

*******************************************************************************

    Bell numbers

*******************************************************************************

void fmpz_bell(fmpz_t b, ulong n)

    Sets \code{b} to the \code{n}:th Bell number $B_n$, defined as the
    number of partitions of a set with \code{n} members. Equivalently,
    $B_n = \sum_{k=0}^n S_2(n,k)$ where $S_2(n,k)$ denotes a Stirling number
    of the second kind.

    This function uses a table lookup if $B_n$ fits in a single word,
    and otherwise evaluates a precise truncation of the series
    $B_n = e^{-1} \sum_{k=0}^{\infty} \frac{k^n}{k!}$ using binary splitting.

void fmpz_bell_vec(fmpz * b, long n)

    Sets \code{b} to the vector of Bell numbers $B_0, B_1, \ldots, B_{n-1}$
    inclusive.

    This function uses table lookup if $B_{n-1}$ fits in a single word,
    and a simple triangular recurrence otherwise.

*******************************************************************************

    Bernoulli numbers and polynomials

*******************************************************************************

void _fmpz_bernoulli_vec_series(fmpz_t den, fmpz * b, long n)

    Computes the Bernoulli numbers $B_0, B_1, \dotsc, B_{n-1}$
    using a generating function. This algorithm is fast for very
    large $n$, say $n > 2000$.

    Conceptually, the algorithm consists of calculating the scaled
    Bernoulli numbers $c_k = B_k / k!$ using the generating function
    $x/(e^x-1)$. The series for $(e^x-1)/x$ is expanded using a simple
    recurrence relation. A single \code{fmpq_poly} inversion is
    then performed, and the resulting coefficients are scaled back to
    obtain the ordinary Bernoulli numbers.

    In fact, we use a slightly different generating function corresponding
    to the scaled coefficients $d_k = 2^{k/2} B_k / k!$ ($k$ even). This
    series is split into four separate power series to improve performance.
    The formula is given in \citep{BuhlerCrandallSompolski1992}.

    %[1] J.P. Buhler, R.E. Crandall, R.W. Sompolski,
    %    "Irregular Primes to One Million", Math. Comp. Vol 59,
    %    No. 200 (Oct. 1992), pp. 717-722.

void _fmpz_bernoulli_vec_recursive(fmpz_t den, fmpz * b, long n)

    Computes the Bernoulli numbers $B_0, B_1, \dotsc, B_{n-1}$
    using table lookup for the initial numbers with single-limb numerators,
    and then using a recursive formula expressing $B_m$ as a sum over
    $B_k$ for $k$ congruent to $m$ modulo 6.

    All operations are performed using integer arithmetic to avoid costly GCDs,
    making this algorithm fast for small $n$, say $n < 1000$. The fully
    reduced denominator is calculated immediately as the primorial of $n + 1$.

    %[1] http://en.wikipedia.org/w/index.php?
    %    title=Bernoulli_number&oldid=405938876

void fmpz_bernoulli_vec(fmpz_t den, fmpz * num, long n)

    Computes the Bernoulli numbers $B_0, B_1, \dotsc, B_{n-1}$ for $n \geq 0$
    as a vector of integer numerators \code{num} with a common
    denominator \code{den}. The denominator is reduced to lowest terms.

void fmpq_poly_bernoulli(fmpq_poly_t poly, long n)

    For $n \geq 0$, sets \code{poly} to the Bernoulli polynomial of degree $n$,
    $B_n(x) = \sum_{k=0}^n \binom{n}{k} B_k x^{n-k}$ where $B_k$
    is a Bernoulli number.

*******************************************************************************

    Multiplicative functions

*******************************************************************************

void fmpz_euler_phi(fmpz_t res, const fmpz_t n)

    Sets \code{res} to the Euler totient function $\phi(n)$, counting the 
    number of positive integers less than or equal to $n$ that are coprime 
    to $n$.

int fmpz_moebius_mu(const fmpz_t n)

    Computes the Moebius function $\mu(n)$, which is defined as $\mu(n) = 0$ 
    if $n$ has a prime factor of multiplicity greater than $1$, $\mu(n) = -1$ 
    if $n$ has an odd number of distinct prime factors, and $\mu(n) = 1$ if 
    $n$ has an even number of distinct prime factors.  By convention, 
    $\mu(0) = 0$.

void fmpz_divisor_sigma(fmpz_t res, const fmpz_t n, ulong k)

    Sets \code{res} to $\sigma_k(n)$, the sum of $k$th powers of all 
    divisors of $n$.

void fmpz_divisors(fmpz_poly_t res, const fmpz_t n)

    Set the coefficients of the polynomial \code{res} to the divisors of $n$, 
    including $1$ and $n$ itself, in ascending order.

void fmpz_ramanujan_tau(fmpz_t res, const fmpz_t n)

    Sets \code{res} to the Ramanujan tau function $\tau(n)$ which is the 
    coefficient of $q^n$ in the series expansion of 
    $f(q) = q  \prod_{k \geq 1} \bigl(1 - q^k\bigr)^{24}$.

    We factor $n$ and use the identity $\tau(pq) = \tau(p) \tau(q)$ 
    along with the recursion 
    $\tau(p^{r+1}) = \tau(p) \tau(p^r) - p^{11} \tau(p^{r-1})$
    for prime powers.

    The base values $\tau(p)$ are obtained using the function 
    \code{fmpz_poly_ramanujan_tau()}. Thus the speed of 
    \code{fmpz_ramanujan_tau()} depends on the largest prime factor of $n$.

    Future improvement:  optimise this function for small $n$, which 
    could be accomplished using a lookup table or by calling 
    \code{fmpz_poly_ramanujan_tau()} directly.

void fmpz_poly_ramanujan_tau(fmpz_poly_t res, long n)

    Sets \code{res} to the polynomial with coefficients 
    $\tau(0),\tau(1), \dotsc, \tau(n-1)$, giving the initial $n$ terms 
    in the series expansion of 
    $f(q) = q \prod_{k \geq 1} \bigl(1-q^k\bigr)^{24}$.

    The algorithm is borrowed from the \code{delta_qexp()} function in 
    Sage, written by William Stein and David Harvey, and consists of 
    expanding the series of the equivalent representation 
    \begin{equation*}
    f(q) = q  \Biggl( \sum_{k \geq 0} (-1)^k (2k+1) q^{k(k+1)/2} \Biggr)^8.
    \end{equation*}

    The first squaring is done directly since the polynomial is very 
    sparse at this point.

