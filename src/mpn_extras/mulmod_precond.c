/*
    Copyright (C) 2012 William Hart
    Copyright (C) 2025 Fredrik Johansson

    This file is part of FLINT.

    FLINT is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License (LGPL) as published
    by the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.  See <https://www.gnu.org/licenses/>.
*/

#include "mpn_extras.h"

/*
    Hack: flint_mpn_mod_preinvn is currently slow for divisions of
    size (n+2,n) or (n+1,n), so we use the following code adapted from
    flint_mpn_mod_preinv1. It would be better to improve flint_mpn_mod_preinvn,
    but this is not straightforward; flint_mpn_mod_preinvn is only
    allowed to overwrite n limbs while the following overwrites m limbs
    (which is fine for the use local to this file).

    Note: flint_mpn_divrem21_preinv is documented as requiring the
    precomputed inverse generated by flint_mpn_preinv1, but it turns out
    that it works to take the top limb of an inverse computed by
    flint_mpn_preinvn.
*/

void flint_mpn_mod_preinv1(mp_ptr a, mp_size_t m,
                                 mp_srcptr b, mp_size_t n, mp_limb_t dinv)
{
    mp_size_t i;
    mp_limb_t q;

    if (mpn_cmp(a + m - n, b, n) >= 0)
        mpn_sub_n(a + m - n, a + m - n, b, n);

    for (i = m - 1; i >= n; i--)
    {
        flint_mpn_divrem21_preinv(q, a[i], a[i - 1], dinv);
        a[i] -= mpn_submul_1(a + i - n, b, n, q);

        if (mpn_cmp(a + i - n, b, n) >= 0 || a[i] != 0)
            a[i] -= mpn_sub_n(a + i - n, a + i - n, b, n);
    }
}

mp_size_t flint_mpn_mulmod_precond_alloc(mp_size_t n)
{
    /* We only need n^2 limbs for the result, but allocate one extra limb
       which flint_mpn_mulmod_precond_precompute can use as scratch space
       to save a copy. */
    return n * n + 1;
}

void
flint_mpn_mulmod_precond_precompute(mp_ptr apre, mp_srcptr a, mp_size_t n, mp_srcptr d, mp_srcptr dinv, ulong norm)
{
    slong i;

    FLINT_ASSERT(n >= 2);

    if (norm == 0)
        flint_mpn_copyi(apre, a, n);
    else
        mpn_lshift(apre, a, n, norm);

    for (i = 1; i < n; i++)
    {
        apre[i * n] = 0;
        flint_mpn_copyi(apre + i * n + 1, apre + (i - 1) * n, n);
#if 0
        flint_mpn_mod_preinvn(apre + i * n, apre + i * n, n + 1, d, n, dinv);
#else
        flint_mpn_mod_preinv1(apre + i * n, n + 1, d, n, dinv[n - 1]);
#endif
    }
}

/* p-mulmod_precond */
int
flint_mpn_mulmod_want_precond(mp_size_t n, slong num)
{
    if (n <= 7 || num <= 3) return 0;
    if (n == 8) return num >= 48;
    if (n == 9) return num >= 16;
    if (n <= 12) return num >= 8;
    if (n <= 64) return num >= 4;
    if (n <= 128) return num >= 6;
    if (n <= 192) return num >= 10;
    if (n <= 256) return num >= 24;
    if (n <= 320) return num >= 48;
    return  0;
}

void
flint_mpn_mulmod_precond(mp_ptr rp, mp_srcptr apre, mp_srcptr b, mp_size_t n, mp_srcptr d, mp_srcptr dinv, ulong norm)
{
    /*
    Note: it is possible to add a special case for n = 2.
    For example, we can do something like

    FLINT_MPN_MUL_2X1(t[2], t[1], t[0], apre[1], apre[0], b[0]);
    FLINT_MPN_MUL_2X1(u[2], u[1], u[0], apre[3], apre[2], b[1]);
    add_ssssaaaaaaaa(t[3], t[2], t[1], t[0], 0, t[2], t[1], t[0], 0, u[2], u[1], u[0]);

    and then reduce mod d using the same operation sequence as in
    flint_mpn_mulmod_preinvn_2.

    We omit this special case as the resulting code does not run
    appreciable faster than flint_mpn_mulmod_preinvn_2.
    */

    mp_ptr tmp;
    mp_limb_t cy;
    slong i, rn;
    TMP_INIT;

    TMP_START;
    tmp = TMP_ALLOC((n + 2) * sizeof(mp_limb_t));

    tmp[n] = mpn_mul_1(tmp, apre, n, b[0]);
    tmp[n + 1] = 0;
    for (i = 1; i < n; i++)
    {
        cy = mpn_addmul_1(tmp, apre + i * n, n, b[i]);
        add_ssaaaa(tmp[n + 1], tmp[n], tmp[n + 1], tmp[n], 0, cy);
    }

    rn = (n + 2) - (tmp[n + 1] == 0);

#if 0
    flint_mpn_mod_preinvn(tmp, tmp, rn, d, n, dinv);
#else
    flint_mpn_mod_preinv1(tmp, rn, d, n, dinv[n - 1]);
#endif

    if (norm == 0)
        flint_mpn_copyi(rp, tmp, n);
    else
        mpn_rshift(rp, tmp, n, norm);

    TMP_END;
}

