/*
    Copyright (C) 2018 Daniel Schultz
    
    This file is part of FLINT.

    FLINT is free software: you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License (LGPL) as published
    by the Free Software Foundation; either version 2.1 of the License, or
    (at your option) any later version.  See <http://www.gnu.org/licenses/>.
*/

*******************************************************************************

    Context object

*******************************************************************************

    An array of type \code{ulong *} or \code{fmpz **} is used to communicate
    exponent vectors. These exponent vectors must have length equal to the
    number of variables in the polynmial ring.
    The element of this exponent vector at index $0$
    corresponds to the most significant variable in the monomial ordering.
    For example, if the polynomial is $7*x^2*y+8*y*z+9$ and the variables are
    ordered so that $x>y>z$, the degree function will return ${2,1,1}$.
    Similarly, the exponent vector of the $0$-index term in this polynomial is
    ${2,1,0}$, while the $2$-index term has exponent vector ${0,0,0}$ and
    coefficient $9$.

void fmpq_mpoly_ctx_init(fmpq_mpoly_ctx_t ctx, 
                                             slong nvars, const ordering_t ord)

    Initialise a context object for a polynomial ring with the given number of
    variables and the given ordering. The possibilities for the ordering are
    \code{ORD_LEX}, \code{ORD_DEGLEX} and \code{ORD_DEGREVLEX}.

void fmpq_mpoly_ctx_clear(fmpq_mpoly_ctx_t ctx)

    Release up any space allocated by an \code{fmpq_mpoly_ctx_t}.

*******************************************************************************

    Memory management

*******************************************************************************

void fmpq_mpoly_init(fmpq_mpoly_t poly, const fmpq_mpoly_ctx_t ctx)

    Initialise \code{poly} for use, given an initialised context object.
    By default, fields of 8
    bits are allocated for the exponents in each exponent vector.

void fmpq_mpoly_init2(fmpq_mpoly_t poly, slong alloc, 
                                                    const fmpq_mpoly_ctx_t ctx)

    Initialise \code{poly} for use, with space for at least
    \code{alloc} terms, given an initialised context.

void fmpq_mpoly_realloc(fmpq_mpoly_t poly, slong len, 
                                                    const fmpq_mpoly_ctx_t ctx)

    Reallocate \code{poly} to have space for \code{len} terms. 
    Assumes the current length of the polynomial is not greater than
    \code{len}.

void fmpq_mpoly_fit_length(fmpq_mpoly_t poly, slong len, 
                                                    const fmpq_mpoly_ctx_t ctx)

    Reallocate \code{poly} to have space for at least
    \code{len} terms. No truncation is performed if \code{len} is less than
    the currently allocated number of terms; the allocated space can only grow.

void fmpq_mpoly_clear(fmpq_mpoly_t poly, const fmpq_mpoly_ctx_t ctx)

    Release any space allocated in \code{poly}.

void fmpq_mpoly_fit_bits(fmpq_mpoly_t poly,
                                         slong bits, const fmpq_mpoly_ctx_t ctx)

    Reallocate the polynomial to have space for exponent fields of the given
    number of bits. This function can increase the number of bits only.

*******************************************************************************

    Basic manipulation

*******************************************************************************

int fmpq_mpoly_degrees_fit_si(const fmpq_mpoly_t poly,
                                                    const fmpq_mpoly_ctx_t ctx)

    Return 1 if the degrees of poly with respect to each variable fit into
    an \code{slong}, otherwise return 0.

void fmpq_mpoly_degrees_si(slong * degs,
                           const fmpq_mpoly_t poly, const fmpq_mpoly_ctx_t ctx)

    Set \code{degs} to the degrees of \code{poly} with respect to each variable.
    If \code{poly} is zero, all degrees are set to \code{-1}.

slong fmpq_mpoly_degree_si(const fmpq_mpoly_t poly, slong var, 
                                                    const fmpq_mpoly_ctx_t ctx)

    Return the degree of \code{poly} with respect to the variable of index
    \code{var}. If \code{poly} is zero, the return is \code{-1}.

void fmpq_mpoly_degrees_fmpz(fmpz ** degs,
                           const fmpq_mpoly_t poly, const fmpq_mpoly_ctx_t ctx)

    Set \code{degs} to the degrees of \code{poly} with respect to each variable.
    If \code{poly} is zero, all degrees are set to \code{-1}.

void fmpq_mpoly_degree_fmpz(fmpz_t deg, const fmpq_mpoly_t poly, slong var, 
                                                    const fmpq_mpoly_ctx_t ctx)

    Set \code{deg} to the degree of \code{poly} with respect to the variable
    of index \code{var}. If \code{poly} is zero, set \code{deg} to \code{-1}.

void fmpq_mpoly_swap(fmpq_mpoly_t poly1, 
                                 fmpq_mpoly_t poly2, const fmpq_mpoly_ctx_t ctx)

    Efficiently swap the contents of the two given polynomials. No copying is
    performed; the swap is accomplished by swapping pointers.

void fmpq_mpoly_set_term_fmpq_ui(fmpq_mpoly_t poly,
                       const fmpq_t c, ulong const * exp, fmpq_mpoly_ctx_t ctx)

    Set the coefficient of the monomial with exponent \code{exp} to \code{c}.

void fmpq_mpoly_set_term_fmpq_fmpz(fmpq_mpoly_t poly,
                       const fmpq_t c, const fmpz ** exp, fmpq_mpoly_ctx_t ctx)

    Set the coefficient of the monomial with exponent \code{exp} to \code{c}.

void fmpq_mpoly_get_term_fmpq_ui(fmpq_t c, const fmpq_mpoly_t poly,
                                 ulong const * exp, const fmpq_mpoly_ctx_t ctx)

    Get the coefficient of the monomial with exponent \code{exp} into \code{c}.

void fmpq_mpoly_get_term_fmpq_fmpz(fmpq_t c, const fmpq_mpoly_t poly,
                                 const fmpq ** exp, const fmpq_mpoly_ctx_t ctx)

    Get the coefficient of the monomial with exponent \code{exp} into \code{c}.

void fmpq_mpoly_get_coeff_monomial(fmpq_t c, const fmpq_mpoly_t poly1,
                           const fmpq_mpoly poly2, const fmpq_mpoly_ctx_t ctx)

    Assuming that \code{poly2} is a monomial, get the coefficient of the
    same monomial in \code{poly1}. This function throws an exception if
    \code{poly2} is not a monomial (i.e. does not have length $1$).


*******************************************************************************

    Container operations

*******************************************************************************

    Some of these functions deal with violations of the internal canonical
    representation. A call to \code{fmpq_mpoly_sort} followed by a call to
    \code{fmpq_mpoly_combine_like_terms} should leave a polynomial in
    canonical form.

slong fmpq_mpoly_length(const fmpq_mpoly_t poly, const fmpq_mpoly_ctx_t ctx)

    Return the number of terms stored in \code{poly}. If the polynomial
    is in canonical form, this will be the number of nonzero coefficients.

void fmpq_mpoly_get_coeff_fmpq(fmpq_t x,
                  const fmpq_mpoly_t poly, slong i, const fmpq_mpoly_ctx_t ctx)

    Set $x$ to coefficient of the given polynomial with index $i$, starting
    with $i = 0$ for the term with most significance.

void fmpq_mpoly_set_coeff_fmpq(fmpq_mpoly_t poly, 
                           slong i, const fmpq_t x, const fmpq_mpoly_ctx_t ctx)

    Set the coefficient of the given polynomial with index $i$ to the given
    value $x$, starting with $i = 0$ for the term with most signifance. Any
    existing term at that index is overwritten.

int fmpq_mpoly_monomial_fits_si(const fmpq_mpoly_t poly,
                                           slong i, const fmpq_mpoly_ctx_t ctx)

    Return 1 if all entries of the exponent vector of the term of index $i$
    fit into an \code{slong}. Otherwise, return 0.

int fmpq_mpoly_monomial_fits_ui(const fmpq_mpoly_t poly,
                                           slong i, const fmpq_mpoly_ctx_t ctx)

    Return 1 if all entries of the exponent vector of the term of index $i$
    fit into a \code{ulong}. Otherwise, return 0.

void fmpq_mpoly_get_monomial_ui(ulong * exps, const fmpq_mpoly_t poly,
                                           slong i, const fmpq_mpoly_ctx_t ctx)

    Get the exponent vector of the given polynomial with index $i$.

void fmpq_mpoly_get_monomial_fmpz(fmpz ** exps, const fmpq_mpoly_t poly,
                                           slong i, const fmpq_mpoly_ctx_t ctx)

    Get the exponent vector of the given polynomial with index $i$.

void fmpq_mpoly_set_monomial_ui(fmpq_mpoly_t poly, 
                       slong i, const ulong * exps, const fmpq_mpoly_ctx_t ctx)

    Set the exponent vector of the given polynomial with index $i$.

void fmpq_mpoly_set_monomial_fmpz(fmpq_mpoly_t poly, 
                       slong i, const fmpz ** exps, const fmpq_mpoly_ctx_t ctx)

    Set the exponent vector of the given polynomial with index $i$.

void fmpq_mpoly_pushback_term_fmpz_fmpz(fmpz_mpoly_t poly,
                     const fmpz_t c, fmpz * const * exp, fmpz_mpoly_ctx_t ctx)

    Append a term to \code{poly} with the given coefficient and exponents.
    If the terms pushed back have bounded denominators, this function
    runs in constant average time, and a term is appened even if $c=0$.

void fmpq_mpoly_pushback_term_fmpz_ui(fmpz_mpoly_t poly,
                             const fmpz_t c, ulong * exp, fmpz_mpoly_ctx_t ctx)

    Append a term to \code{poly} with the given coefficient and exponents.
    If the terms pushed back have bounded denominators, this function
    runs in constant average time, and a term is appened even if $c=0$.

void fmpq_mpoly_sort(fmpq_mpoly_t poly, fmpq_mpoly_ctx_t ctx)

    Assuming that the terms of \code{poly} are otherwise valid, sort the
    terms into the canonical ordering dictated by the ordering in \code{ctx}.
    This function does not combine like terms, nor does it delete terms with
    coefficient zero. Even if all terms have distinct exponent vectors, the
    result may still not be in canonical form.

void fmpq_mpoly_combine_like_terms(fmpq_mpoly_t poly, fmpz_mpoly_ctx_t ctx)

    Combine adjacent like terms in \code{poly}. If the terms of \code{poly}
    were sorted to begin with, the result will be in canonical form.

*******************************************************************************

    Set and negate

*******************************************************************************

void fmpq_mpoly_set(fmpq_mpoly_t poly1, const fmpq_mpoly_t poly2,
                                                    const fmpq_mpoly_ctx_t ctx)
    
    Set \code{poly1} to \code{poly2}.

void fmpq_mpoly_zero(fmpq_mpoly_t poly, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly} to the constant 0.

void fmpq_mpoly_one(fmpq_mpoly_t poly, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly} to the constant 1.

void fmpq_mpoly_set_fmpq(fmpq_mpoly_t poly,
                                    const fmpq_t c, const fmpq_mpoly_ctx_t ctx)

    Set the given \code{fmpq_mpoly_t} to the constant polynomial corresponding
    to the rational number $c$.

void fmpq_mpoly_gen(fmpq_mpoly_t poly, slong i, const fmpq_mpoly_ctx_t ctx)

    Set the given \code{fmpq_mpoly_t} to the $i$-th generator (variable),
    where $i = 0$ corresponds to the variable with the most significance
    with respect to the ordering. 

void fmpq_mpoly_neg(fmpq_mpoly_t poly1, const fmpq_mpoly_t poly2,
                                                    const fmpq_mpoly_ctx_t ctx)
    
    Set \code{poly1} to $-$\code{poly2}.

*******************************************************************************

    Comparison

*******************************************************************************

int fmpq_mpoly_equal(fmpq_mpoly_t poly1, const fmpq_mpoly_t poly2,
                                                    const fmpq_mpoly_ctx_t ctx)

    Return 1 if \code{poly1} is equal to \code{poly2}, else return 0.

int fmpq_mpoly_equal_fmpq(const fmpq_mpoly_t poly,
                                          fmpq_t c, const fmpq_mpoly_ctx_t ctx)

    Return 1 if \code{poly} is equal to the constant $c$, else return 0.

int fmpq_mpoly_equal_fmpz(const fmpq_mpoly_t poly,
                                          fmpq_t c, const fmpq_mpoly_ctx_t ctx)

    Return 1 if \code{poly} is equal to the constant $c$, else return 0.

int fmpq_mpoly_equal_ui(const fmpq_mpoly_t poly,
                                          fmpq_t c, const fmpq_mpoly_ctx_t ctx)

    Return 1 if \code{poly} is equal to the constant $c$, else return 0.

int fmpq_mpoly_equal_si(const fmpq_mpoly_t poly,
                                          fmpq_t c, const fmpq_mpoly_ctx_t ctx)

    Return 1 if \code{poly} is equal to the constant $c$, else return 0.

int fmpq_mpoly_is_fmpq(fmpq_t x, fmpq_mpoly_t poly1, const fmpq_mpoly_ctx_t ctx)

    If \code{poly1} is a constant, set $x$ to that constant and return 1.
    Otherwise, return 0.

int fmpq_mpoly_is_zero(const fmpq_mpoly_t poly, const fmpq_mpoly_ctx_t ctx)

    Return 1 if \code{poly} is equal to the constant 0, else return 0.

int fmpq_mpoly_is_one(const fmpq_mpoly_t poly, const fmpq_mpoly_ctx_t ctx)

    Return 1 if \code{poly} is equal to the constant 1, else return 0.

int fmpq_mpoly_is_gen(const fmpq_mpoly_t poly,
                                           slong i, const fmpq_mpoly_ctx_t ctx)

    If $i \ge 0$, return 1 if \code{poly} is equal to the $i$-th generator,
    otherwise return 0. If $i < 0$, return 1 if the polynomial is
    equal to any generator, otherwise return 0.

int fmpq_mpoly_is_monomial(const fmpq_mpoly_t poly, const fmpq_mpoly_ctx_t ctx)

    Return 1 if \code{poly} is a monomial (i.e. length 1), otherwise return 0.

*******************************************************************************

    Basic arithmetic

*******************************************************************************

void fmpq_mpoly_add_fmpq(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, const fmpq_t c, const fmpq_mpoly_ctx_t ctx);

    Set \code{poly1} to \code{poly2} plus $c$.

void fmpq_mpoly_add_fmpz(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, const fmpz_t c, const fmpq_mpoly_ctx_t ctx);

    Set \code{poly1} to \code{poly2} plus $c$.

void fmpq_mpoly_add_ui(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, ulong        c, const fmpq_mpoly_ctx_t ctx);

    Set \code{poly1} to \code{poly2} plus $c$.

void fmpq_mpoly_add_si(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, slong        c, const fmpq_mpoly_ctx_t ctx);

    Set \code{poly1} to \code{poly2} plus $c$.

void fmpq_mpoly_sub_fmpq(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, const fmpq_t c, const fmpq_mpoly_ctx_t ctx);

    Set \code{poly1} to \code{poly2} minus $c$.

void fmpq_mpoly_sub_fmpz(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, const fmpz_t c, const fmpq_mpoly_ctx_t ctx);

    Set \code{poly1} to \code{poly2} minus $c$.

void fmpq_mpoly_sub_ui(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, ulong        c, const fmpq_mpoly_ctx_t ctx);

    Set \code{poly1} to \code{poly2} minus $c$.

void fmpq_mpoly_sub_si(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, slong        c, const fmpq_mpoly_ctx_t ctx);

    Set \code{poly1} to \code{poly2} minus $c$.

void fmpq_mpoly_add(fmpq_mpoly_t poly1, const fmpq_mpoly_t poly2,
                          const fmpq_mpoly_t poly3, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} plus \code{poly3}.

void fmpq_mpoly_sub(fmpq_mpoly_t poly1, const fmpq_mpoly_t poly2,
                          const fmpq_mpoly_t poly3, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} minus \code{poly3}.

*******************************************************************************

    Scalar operations

*******************************************************************************

void fmpq_mpoly_scalar_mul_fmpq(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, const fmpq_t c, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} times $c$.

void fmpq_mpoly_scalar_mul_fmpz(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, const fmpz_t c, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} times $c$.

void fmpq_mpoly_scalar_mul_ui(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, ulong        c, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} times $c$.

void fmpq_mpoly_scalar_mul_si(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, slong        c, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} times $c$.

void fmpq_mpoly_scalar_div_fmpq(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, const fmpq_t c, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} divided by $c$.

void fmpq_mpoly_scalar_div_fmpz(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, const fmpz_t c, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} divided by $c$.

void fmpq_mpoly_scalar_div_ui(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, ulong        c, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} divided by $c$.

void fmpq_mpoly_scalar_div_si(fmpq_mpoly_t poly1,
         const fmpq_mpoly_t poly2, slong        c, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} divided by $c$.

void fmpq_mpoly_make_monic_inplace(fmpq_mpoly_t poly1,
                                                    const fmpq_mpoly_ctx_t ctx)

    Divide \code{poly1} by its leading coefficient. An expection is raised if
    \code{poly1} is zero.

*******************************************************************************

    Multiplication

*******************************************************************************

void fmpq_mpoly_mul(fmpq_mpoly_t poly1,
                 const fmpq_mpoly_t poly2, const fmpq_mpoly_t poly3, 
                                                    const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} times \code{poly3}.

void fmpq_mpoly_mul_threaded(fmpq_mpoly_t poly1,
                 const fmpq_mpoly_t poly2, const fmpq_mpoly_t poly3,
                                                   const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} times \code{poly3} using multiple threads.

*******************************************************************************

    Powering

*******************************************************************************

void fmpq_mpoly_pow_fmpz(fmpq_mpoly_t poly1, const fmpq_mpoly_t poly2,
                                    const fmpz_t k, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} raised to the $k$-th power.
    An expection is raised if $k < 0$ or if $k$ is large and the polynomial is
    not a monomial with coefficient $\pm1$.

void fmpq_mpoly_pow_si(fmpq_mpoly_t poly1, const fmpq_mpoly_t poly2,
                                           slong k, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} raised to the $k$-th power.
    An expection is raised if $k < 0$.

*******************************************************************************

    Divisibility testing

*******************************************************************************

int fmpq_mpoly_divides(fmpq_mpoly_t poly1,
                  const fmpq_mpoly_t poly2, const fmpq_mpoly_t poly3,
                                                    const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to \code{poly2} divided by \code{poly3} and return 1 if
    the quotient is exact. Otherwise return 0.

*******************************************************************************

    Division

*******************************************************************************

void fmpq_mpoly_div(fmpq_mpoly_t polyq,
                     const fmpq_mpoly_t poly2, const fmpq_mpoly_t poly3,
                                                    const fmpq_mpoly_ctx_t ctx)

    Set \code{polyq} to the quotient of \code{poly2} by \code{poly3},
    discarding the remainder. An expection is currently raised if \code{poly2}
    or \code{poly3} have bit counts greater than \code{FLINT_BITS}.

void fmpq_mpoly_divrem(fmpq_mpoly_t q, fmpq_mpoly_t r,
                  const fmpq_mpoly_t poly2, const fmpq_mpoly_t poly3,
                                                    const fmpq_mpoly_ctx_t ctx)

    Set \code{polyq} and \code{polyr} to the quotient and remainder of
    \code{poly2} divided by \code{poly3}. An expection is 
    currently raised if \code{poly2}
    or \code{poly3} have bit counts greater than \code{FLINT_BITS}.

*******************************************************************************

    Reduction

*******************************************************************************

void fmpq_mpoly_divrem_ideal(fmpq_mpoly_struct ** q,
                                fmpq_mpoly_t r, const fmpq_mpoly_t poly2,
      fmpq_mpoly_struct * const * poly3, slong len, const fmpq_mpoly_ctx_t ctx)

    This function is as per \code{fmpq_mpoly_divrem} except
    that it takes an array of divisor polynomials \code{poly3}, and it returns
    an array of quotient polynomials \code{q}. The number of divisor (and hence
    quotient) polynomials, is given by \code{len}. The function computes
    polynomials $q_i = q[i]$ such that \code{poly2} is
    $r + \sum_{i=0}^{\mbox{len - 1}} q_ib_i$, where $b_i =$ \code{poly3[i]}.
    An expection is currently raised 
    if any input polynomials have bit counts greater than \code{FLINT_BITS}.

*******************************************************************************

    Differentiation/Integration

*******************************************************************************

void fmpq_mpoly_derivative(fmpq_mpoly_t poly1,
               const fmpq_mpoly_t poly2, slong var, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to the derivative of \code{poly2} with respect to the
    variable of index \code{var}.

void fmpq_mpoly_integral(fmpq_mpoly_t poly1,
               const fmpq_mpoly_t poly2, slong var, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to the integral with the fewest number of terms
    of \{poly2} with respect to the variable of index \code{var}.

*******************************************************************************

    Evaluation (not implemented yet)

*******************************************************************************

void fmpq_mpoly_evaluate_all_fmpq(fmpq_t ev, fmpq_mpoly_t poly,
                                            fmpq ** vals, fmpq_mpoly_ctx_t ctx)

    Set \code{ev} to the evaluation of \code{poly} where the variables are
    replaced by the corresponding elements of the array \code{vals}.

void fmpq_mpoly_evaluate_one_fmpq(fmpq_mpoly_t poly1, fmpq_mpoly_t poly2,
                                   slong var, fmpq_t val, fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to the evaluation of \code{poly2} where the variable of
    index \code{var} is replaced by \code{val}.

void fmpq_mpoly_compose(fmpq_mpoly_t res, fmpq_mpoly_t poly1,
     fmpq_mpoly_struct ** polys2, fmpq_mpoly_ctx_t ctx1, fmpq_mpoly_ctx_t ctx2)

    Set \code{res} to the evaluation of \code{poly1} where the variables are
    replaced by the corresponding elements of the array \code{polys2}. Both
    \code{res} and the elements of \code{polys2} have context object
    \code{ctx2}, while \code{poly1} has context object \code{ctx1}. Neither of
    \code{res} and \code{poly1} is allowed to alias any other polynomial.

*******************************************************************************

    Greatest Common Divisor

*******************************************************************************

int fmpq_mpoly_gcd(fmpq_mpoly_t poly1, const fmpq_mpoly_t poly2,
                          const fmpq_mpoly_t poly3, const fmpq_mpoly_ctx_t ctx)

    Set \code{poly1} to the monic GCD of \code{poly2} and \code{poly3}, assuming
    the return value is 1. If the return value is 0, the GCD was
    unable to be computed.

*******************************************************************************

    Input/Output

*******************************************************************************

char * fmpq_mpoly_get_str_pretty(const fmpq_mpoly_t poly,
                                   const char ** x, const fmpq_mpoly_ctx_t ctx)

    Return a string (which the user is responsible for cleaning up),
    representing \code{poly}, given an array of variable strings, starting
    with the variable of most significance with respect to the ordering. 

int fmpq_mpoly_fprint_pretty(FILE * file, 
          const fmpq_mpoly_t poly, const char ** x, const fmpq_mpoly_ctx_t ctx)

    Print to the given stream a string representing \code{poly}, given an
    array of variable strings, starting with the variable of most
    significance with respect to the ordering. The number of characters
    written is returned.

int fmpq_mpoly_print_pretty(const fmpq_mpoly_t poly,
                                   const char ** x, const fmpq_mpoly_ctx_t ctx)

    Print to \code{stdout} a string representing \code{poly}, given an
    array of variable strings, starting with the variable of most
    significance with respect to the ordering. The number of characters
    written is returned.

int fmpq_mpoly_set_str_pretty(fmpq_mpoly_t poly, const char * str,
                                   const char ** x, const fmpq_mpoly_ctx_t ctx)

    Sets \code{poly} to the polynomial in the null-terminated string \code{str}
    given an array \code{x} of variable strings. If parsing \code{str} fails,
    \code{poly} is set to zero, and \code{-1} is returned. Otherwise, \code{0}
    is returned. The operations \code{+}, \code{-}, \code{*}, and \code{/} are
    permitted along with integers and the variables in \code{x}. The character
    \code{^} must be immediately followed by the (integer) exponent. If any
    division is not exact, parsing fails.

*******************************************************************************

    Random generation

*******************************************************************************

void fmpq_mpoly_randtest_bound(fmpq_mpoly_t poly, flint_rand_t state,
                   slong length, mp_limb_t coeff_bits, slong exp_bound,
                                                    const fmpq_mpoly_ctx_t ctx)

    Generate a random polynomial with the number of variables and ordering
    specified by \code{ctx}, and with length up to the given length, exponents
    which don't exceed the given bound and with signed coefficients of the
    given number of bits.

void fmpq_mpoly_randtest_bits(fmpq_mpoly_t poly, flint_rand_t state,
                   slong length, mp_limb_t coeff_bits, mp_limb_t exp_bits,
                                                    const fmpq_mpoly_ctx_t ctx)

    Generate a random polynomial with the number of variables and ordering
    specified by \code{ctx}, and with length up to the given length, exponents
    whose packed form don't exceed the given bit count, and with signed
    coefficients of the given number of bits.
