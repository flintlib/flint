.. _nmod-sparse-mat:

**nmod_sparse_mat.h** -- sparse matrices over integers mod n
===============================================================================

Description.

Types, macros and constants
-------------------------------------------------------------------------------

.. type:: nmod_sparse_mat_t

    Holds an array of (possibly empty) sparse vectors corresponding to rows in 
    the matrix

Memory management
--------------------------------------------------------------------------------

.. function:: void nmod_sparse_mat_init(nmod_sparse_mat_t M, slong rows, slong cols, nmod_t mod)

    Initializes an empty sparse matrix ``M`` with given number of rows and columns

.. function:: void nmod_sparse_mat_clear(nmod_sparse_mat_t M)

    Clears the entries of the matrix ``M`` and frees the space allocated for it

.. function:: void nmod_sparse_mat_swap(nmod_sparse_mat_t M1, nmod_sparse_mat_t M2)

    Swaps two matrices ``M1`` and ``M2`` (no reallocaton)


Instantiation
--------------------------------------------------------------------------------

.. function:: void nmod_sparse_mat_zero(nmod_sparse_mat_t M)

    Sets matrix ``M`` to zero (the empty sparse matrix)

.. function:: void nmod_sparse_mat_one(nmod_sparse_mat_t M)

    Sets matrix ``M`` to identity matrix (based on its number of rows)

.. function:: void nmod_sparse_mat_set(nmod_sparse_mat_t N, const nmod_sparse_mat_t M)

    Makes ``N`` a (deep) copy of ``M``

.. function:: void nmod_sparse_mat_from_entries(nmod_sparse_mat_t M, slong *rows, slong *inds, mp_ptr vals, slong nnz)

    Constructs matrix ``M`` from a given sequence of ``rows``, ``cols``, and 
    corresponding ``vals``, all of length ``nnz``, assumes sorted by rows 
    with no duplicate (row, col) indices

.. function:: void nmod_sparse_mat_append_col(nmod_sparse_mat_t M, mp_srcptr v)

    Add a dense column to the right of the matrix

.. function:: void nmod_sparse_mat_append_row(nmod_sparse_mat_t M, const nmod_sparse_vec_t v)

    Add a sparse row to the bottom of the matrix


Conversion to/from dense matrix
--------------------------------------------------------------------------------

.. function:: void nmod_sparse_mat_from_dense(nmod_sparse_mat_t M, const nmod_mat_t dM)

    Converts the dense matrix ``dM`` to a sparse matrix ``M``

.. function:: void nmod_sparse_mat_to_dense(nmod_mat_t dM, const nmod_sparse_mat_t M)

    Converts the sparse matrix ``M`` to a dense matrix ``dM``

Windows, concatenation, and splitting
--------------------------------------------------------------------------------

.. function:: void nmod_sparse_mat_window_init(nmod_sparse_mat_t window, const nmod_sparse_mat_t M, slong r1, slong c1, slong r2, slong c2)

    Constructs a window on the sparse matrix ``M`` between rows ``r1`` and ``r2`` 
    and cols ``c1`` and ``c2`` (valid as long as original matrix remains uzechified)

.. function:: void nmod_sparse_mat_window_clear(nmod_sparse_mat_t window)

    Clears a window

.. function:: void nmod_sparse_mat_concat_horizontal(nmod_sparse_mat_t B, const nmod_sparse_mat_t M1, const nmod_sparse_mat_t M2)

    Horizontally concatenates two matrices ``M1`` and ``M2`` into block matrix ``B``

.. function:: void nmod_sparse_mat_concat_vertical(nmod_sparse_mat_t B, const nmod_sparse_mat_t M1, const nmod_sparse_mat_t M2)

    Vertically concatenates two matrices ``M1`` and ``M2`` into block matrix ``B``

.. function:: void nmod_sparse_mat_split_horizontal(nmod_sparse_mat_t M1, nmod_sparse_mat_t M2, const nmod_sparse_mat_t B, slong c)

    Splits ``B`` horizontally into two submatrices ``M1`` and ``M2``, dividing at column ``c``

.. function:: void nmod_sparse_mat_split_vertical(nmod_sparse_mat_t M1, nmod_sparse_mat_t M2, const nmod_sparse_mat_t B, slong r)

    Splits ``B`` vertically into two submatrices ``M1`` and ``M2``, dividing at row ``r``


Permutation
--------------------------------------------------------------------------------

.. function:: void nmod_sparse_mat_permute_cols(nmod_sparse_mat_t M,  slong *Q)

    Permutes the columns indices of ``M`` according to ``Q``, and re-sorts each row

.. function:: void nmod_sparse_mat_permute_rows(nmod_sparse_mat_t M,  slong *P)

    Permutes the rows of ``M`` according to ``P``


Randomization
--------------------------------------------------------------------------------


.. function:: void nmod_sparse_mat_randtest(nmod_sparse_mat_t M, flint_rand_t state, slong min_nnz, slong max_nnz)

    Makes ``M`` a sparse matrix with between ``min_nnz`` and ``max_nnz`` nonzero 
    entries per row, with individual entries generated by nmod_randtest


Output
--------------------------------------------------------------------------------

.. function:: void nmod_sparse_mat_print_pretty(const nmod_sparse_mat_t M)

    Prints the matrix ``M`` to ``stdout`` in a human-readable format


Comparison
--------------------------------------------------------------------------------

.. function:: void nmod_sparse_is_zero(nmod_sparse_mat_t M)

    Checks if the given matrix ``M`` is trivial (empty), returning `1` if so and `0` 
    otherwise

.. function:: void nmod_sparse_mat_equal(nmod_sparse_mat_t M1, nmod_sparse_mat_t M2, slong ioff)

    Checks if ``M1`` equals ``M2``, returning `1` if so and `0` otherwise


Transpose
--------------------------------------------------------------------------------

.. function:: void nmod_sparse_mat_transpose(nmod_sparse_mat_t N, nmod_sparse_mat_t M)

    Transposes ``M`` into the matrix ``N`` (must have swapped rows and columns)


Arithmetic
--------------------------------------------------------------------------------

.. function:: void nmod_sparse_mat_neg(nmod_sparse_mat_t N, const nmod_sparse_mat_t M)

    Sets ``N`` to the negation of ``M``

.. function:: void nmod_sparse_mat_scalar_mul_nmod(nmod_sparse_mat_t N, const nmod_sparse_mat_t M, const nmod_t c)

    Sets ``N`` to the scalar multiple of ``M`` by ``c``

.. function:: void nmod_sparse_mat_add(nmod_sparse_mat_t O, const nmod_sparse_mat_t M, const nmod_sparse_mat_t N)

    Sets ``O`` to the sum of ``M`` and ``N``

.. function:: void nmod_sparse_mat_sub(nmod_sparse_mat_t O, const nmod_sparse_mat_t M, const nmod_sparse_mat_t N)

    Sets ``O`` to the difference of ``M`` and ``N``

.. function:: void nmod_sparse_mat_scalar_addmul_nmod(nmod_sparse_mat_t O, const nmod_sparse_mat_t M, const nmod_sparse_mat_t N, const nmod_t c)

    Sets ``O`` to the sum of ``M`` and ``c` times ``N``

.. function:: void nmod_sparse_mat_scalar_submul_nmod(nmod_sparse_mat_t O, const nmod_sparse_mat_t M, const nmod_sparse_mat_t N, const nmod_t c)

    Sets ``O`` to the difference of ``M`` and ``N` times ``v``

.. function:: void nmod_sparse_mat_mul_vec(mp_ptr y, const nmod_sparse_mat_t M, mp_srcptr x)

    Sets ``y`` to the product of ``M`` and ``x``

.. function:: void nmod_sparse_mat_mul_mat(nmod_mat_t Y, const nmod_sparse_mat_t M, const nmod_mat_t X)

    Sets ``Y`` to the product of ``M`` and ``X``

.. function:: slong nmod_sparse_mat_inv(nmod_sparse_mat_t N, const nmod_sparse_mat_t M)

    Sets ``N`` to the "inverse" of ``M``, i.e., the matrix such that NM is
    in reduced row-echelon form


Decomposition/reduction
--------------------------------------------------------------------------------

.. function:: slong nmod_sparse_mat_lu(slong *P, slong *Q, nmod_sparse_mat_t L, nmod_sparse_mat_t U, const nmod_sparse_mat_t M)

    Computes the decomposition PMQ = LU for a given sparse matrix ``M``, where 
    ``P`` is a row permutation, ``Q`` is a column permutation, ``L``is a lower
    triangular matrix, and ``U`` is an upper triangular matrix, returns the rank

.. function:: slong nmod_sparse_mat_rref(nmod_sparse_mat_t M)

    Applies row reduction to put ``M`` in reduced row echelon form (in place)
    and returns the rank

Solving
--------------------------------------------------------------------------------

.. function:: int nmod_sparse_mat_solve_lu(mp_ptr x, const nmod_sparse_mat_t M, mp_srcptr b)

    Given a matrix ``M`` and target vector ``b``, use LU decomposition to find
    a vector ``x`` such that Mx = b, returns `1` if successful and `0` if not

.. function:: int nmod_sparse_mat_solve_rref(mp_ptr x, const nmod_sparse_mat_t M, mp_srcptr b)

    Given a matrix ``M`` and target vector ``b``, use the reduced row-echelon
    form to find a vector ``x`` such that Mx = b, returns `1` if successful and 
    `0` if not

.. function:: int nmod_sparse_mat_solve_lanczos(mp_ptr x, const nmod_sparse_mat_t M, mp_srcptr b, flint_rand_t state)

    Given a matrix ``M`` and target vector ``b``, use the Lanczos algorithm to
    find a vector ``x`` such that Mx = b, returns `1` if successful and `0` if not

.. function:: int nmod_sparse_mat_solve_wiedemann(mp_ptr x, const nmod_sparse_mat_t M, mp_srcptr b)

    Given a matrix ``M`` and target vector ``b``, use the Wiedemann algorithm to
    find a vector ``x`` such that Mx = b, returns `1` if successful and `0` if not

.. function:: int nmod_sparse_mat_solve_block_lanczos(mp_ptr x, const nmod_sparse_mat_t M, mp_srcptr b, slong block_size, flint_rand_t state)

    Given a matrix ``M`` and target vector ``b``, use Coppersmith's block Lanczos 
    algorithm (with specified block size) to find a vector ``x`` such that Mx = b, 
    returns `1` if successful and `0` if not

.. function:: int nmod_sparse_mat_solve_block_wiedemann(mp_ptr x, const nmod_sparse_mat_t M, mp_srcptr b, slong block_size, flint_rand_t state)

    Given a matrix ``M`` and target vector ``b``, use Coppersmith's block Wiedemann
    algorithm (with specified block size) to find a vector ``x`` such that Mx = b, 
    returns `1` if successful and `0` if not

Nullvector and nullspace computation
--------------------------------------------------------------------------------

.. function:: int nmod_sparse_mat_nullvector_lanczos(mp_ptr x, const nmod_sparse_mat_t M, flint_rand_t state)

    Given a matrix ``M``, use the Lanczos algorithm to find a nullvector ``x`` 
    s.t. Mx = 0, returns `1` if successful and `0` if not

.. function:: int nmod_sparse_mat_nullvector_wiedemann(mp_ptr x, const nmod_sparse_mat_t M, flint_rand_t state)

    Given a matrix ``M``, use the Wiedemann algorithm to find a nullvector ``x`` 
    s.t. Mx = 0, returns `1` if successful and `0` if not

.. function:: int nmod_sparse_mat_nullvector_block_lanczos(mp_ptr x, const nmod_sparse_mat_t M, slong block_size, flint_rand_t state)

    Given a matrix ``M``, use Coppersmith's block Lanczos algorithm to find a 
    nullvector ``x`` s.t. Mx = 0, returns `1` if successful and `0` if not

.. function:: int nmod_sparse_mat_nullvector_block_wiedemann(mp_ptr x, const nmod_sparse_mat_t M, slong block_size, flint_rand_t state)

    Given a matrix ``M``, use Coppersmith's block Wiedemann algorithm to find a 
    nullvector ``x`` s.t. Mx = 0, returns `1` if successful and `0` if not

.. function:: int nmod_sparse_mat_nullspace_rref(nmod_mat_t X, const nmod_sparse_mat_t M)

    Given a matrix ``M``, use the reduced row echelon form to construct the 
    nullspace ``X`` of M (initialized by this function), returns the nullity

.. function:: int nmod_sparse_mat_nullspace_lu(nmod_mat_t X, const nmod_sparse_mat_t M)

    Given a matrix ``M``, use the LU decomposition to construct the nullspace ``X``
    of M (initialized by this function), returns the nullity

.. function:: int nmod_sparse_mat_nullspace_lanczos(nmod_mat_t X, const nmod_sparse_mat_t M, flint_rand_t state)

    Given a matrix ``M``, use the Lanczos algorithm to find a nullspace ``X`` 
    of M (initialized by this function), returns the found nullity

.. function:: int nmod_sparse_mat_nullspace_wiedemann(nmod_mat_t X, const nmod_sparse_mat_t M, flint_rand_t state)

    Given a matrix ``M``, use the Wiedemann algorithm to find a nullspace ``X`` 
    of M (initialized by this function), returns the found nullity

.. function:: int nmod_sparse_mat_nullspace_block_lanczos(nmod_mat_t X, const nmod_sparse_mat_t M, slong block_size, flint_rand_t state)

    Given a matrix ``M``, use Coppersmith's block Lanczos algorithm to find a 
    nullspace ``X`` of M (initialized by this function), returns the found nullity

.. function:: int nmod_sparse_mat_nullspace_block_wiedemann(nmod_mat_t X, const nmod_sparse_mat_t M, slong block_size, flint_rand_t state)

    Given a matrix ``M``, use Coppersmith's block Wiedemann algorithm to find a 
    nullspace ``X`` of M (initialized by this function), returns the found nullity

